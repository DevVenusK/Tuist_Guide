타겟 제품에 따라(예: 앱, 프레임워크), 리소스에 접근하는 방법이 다릅니다.
예를 들어, 앱 타겟의 일부인 이미지를 가져오려면 ```Bundle.main```에서 이미지를 가져옵니다. 
반면, 이미지가 프레임워크의 일부인 경우 ```FrameworkClass.self```에 해당하는 ```Bundle```에서 액세스합니다. 
리소스에 ***일관성 없는 인터페이스***를 가지고 있다면, 코드와 리소스를 이동하는 것이 복잡해집니다.

또한 알 수 있듯이, 라이브러리는 리소스를 포함할 수 없습니다.
리소스를 포함할 수 있는 것은 프레임워크 뿐입니다. 
iOS에서는 이러한 이유로 프로젝트가 정적 라이브러리 대신 동적 프레임워크를 사용하며, 경우에 따라 종속성에서 리소스를 최종 제품(앱)으로 복사하는 사용자 지정 빌드 단계를 추가합니다.
이러한 설정을 사용하면 부작용이 발생하며 프로젝트 유지 관리가 복잡해지며, 설정을 이해하기 어려워집니다.

## 리소스에 일관성 있는 접근 방법

Tuist는 타겟 유형에 따라 올바른 번들에 액세스하기 위한 ```Bundle``` 확장을 생성하여 이 문제를 해결합니다.
예를 들어, ```MyFeature```라는 타겟 프레임워크가 있다면 다음과 같이 올바른 번들을 가져올 수 있습니다:
```swift
let bundle = Bundle.module
```
또한, 리소스를 지원하지 않는 제품(예: 라이브러리)에서도 리소스를 정의할 수 있습니다.
이 경우, 모든 리소스를 포함하는 연관된 번들 타겟```(MyFeatureResources.bundle)```을 생성합니다.
번들은 컴파일된 타겟이 포함된 최종 제품 번들에 복사됩니다.

> ℹ️ **강력히 권장됨**
> 
> 이러한 방식으로 리소스에 액세스하는 것은 필수적이지는 않지만, 강력히 권장합니다. 이 방식을 사용하면 라이브러리를 프레임워크로 전환하는 등 프로젝트에서 변경을 용이하게 할 수 있습니다.

> ⚠️ **아직 즉석에서 리소스 액세서 생성을 지원하지 않음**
> 
> 이 방식을 코드베이스에서 적용하기 전에, Tuist의 리소스 액세서 생성 기능은 즉석에서 작동하지 않는다는 점을 주의해야 합니다.
> 즉, 리소스를 추가하거나 변경한 경우 ```tuist generate```를 실행하여 리소스 액세서를 다시 생성하여 변경 내용을 반영해야 합니다.
>
> 자세한 내용은 이 이슈를 참조하십시오.
